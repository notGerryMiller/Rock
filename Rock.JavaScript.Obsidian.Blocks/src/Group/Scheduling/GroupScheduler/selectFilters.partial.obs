<!-- Copyright by the Spark Development Network; Licensed under the Rock Community License -->
<template>
    <Modal v-model="isVisible" title="Filters" saveText="Apply" @save="onSave">

        <Alert :alertType="AlertType.Info">
            Select the filter options below to limit what is shown on the group scheduler.
        </Alert>

        <Alert v-if="warningMessage" :alertType="AlertType.Warning">
            {{ warningMessage }}
        </Alert>

        <GroupPicker v-model="selectedGroups"
                     label="Groups"
                     :multiple="true"
                     :limitToSchedulingEnabled="true"
                     :autoExpand="true"
                     :disabled="isUpdatingFilters"
                     @update:modelValue="onFiltersChanged('GroupPicker', $event)" />

        <SlidingDateRangePicker v-model="selectedDateRange"
                                label="Dates"
                                :disabled="isUpdatingFilters"
                                @update:modelValue="onFiltersChanged('SlidingDateRangePicker', $event)" />

        <DropDownList v-model="selectedLocationIds"
                      label="Locations"
                      :items="availableLocations"
                      :multiple="true"
                      :loading="isUpdatingFilters"
                      @blur="onFiltersChanged('LocationsPicker', $event)" />

        <DropDownList v-model="selectedScheduleIds"
                      label="Schedules"
                      :items="availableSchedules"
                      :multiple="true"
                      :loading="isUpdatingFilters"
                      @blur="onFiltersChanged('SchedulesPicker', $event)" />

    </Modal>
</template>

<script setup lang="ts">
    import { computed, nextTick, PropType, ref, watch } from "vue";
    import Alert from "@Obsidian/Controls/alert.obs";
    import DropDownList from "@Obsidian/Controls/dropDownList";
    import GroupPicker from "@Obsidian/Controls/groupPicker";
    import Modal from "@Obsidian/Controls/modal";
    import SlidingDateRangePicker from "@Obsidian/Controls/slidingDateRangePicker";
    import { AlertType } from "@Obsidian/Enums/Controls/alertType";
    import { useInvokeBlockAction } from "@Obsidian/Utility/block";
    import { useVModelPassthrough } from "@Obsidian/Utility/component";
    import { SlidingDateRange } from "@Obsidian/Utility/slidingDateRange";
    import { GroupSchedulerFiltersBag } from "@Obsidian/ViewModels/Blocks/Group/Scheduling/GroupScheduler/groupSchedulerFiltersBag";
    import { SlidingDateRangeBag } from "@Obsidian/ViewModels/Controls/slidingDateRangeBag";
    import { ListItemBag } from "@Obsidian/ViewModels/Utility/listItemBag";

    const invokeBlockAction = useInvokeBlockAction();

    const props = defineProps({
        isVisible: {
            type: Boolean as PropType<boolean>,
            required: true
        },

        appliedFilters: {
            type: Object as PropType<GroupSchedulerFiltersBag>,
            required: true
        }
    });

    const emit = defineEmits<{
        (e: "update:isVisible"): void,
        (e: "applyFilters", value: GroupSchedulerFiltersBag): void
    }>();

    // #region Values

    const isVisible = useVModelPassthrough(props, "isVisible", emit);

    const isUpdatingFilters = ref(false);
    const warningMessage = ref("");
    const isCanceled = ref(true);

    const originalValue = ref(props.appliedFilters);

    const selectedGroups = ref<ListItemBag[]>(props.appliedFilters?.groups ?? []);
    const selectedDateRange = ref<SlidingDateRange | null>(getSlidingDateRange(props.appliedFilters?.dateRange));
    const availableLocations = ref<ListItemBag[]>(props.appliedFilters?.locations?.availableLocations ?? []);
    const selectedLocations = ref<ListItemBag[]>(props.appliedFilters?.locations?.selectedLocations ?? []);
    const availableSchedules = ref<ListItemBag[]>(props.appliedFilters?.schedules?.availableSchedules ?? []);
    const selectedSchedules = ref<ListItemBag[]>(props.appliedFilters?.schedules?.selectedSchedules ?? []);

    // #endregion

    // #region Computed Values

    const selectedLocationIds = computed<string[]>({
        get() {
            return selectedLocations.value
                ?.filter((item: ListItemBag) => item?.value)
                ?.map((item: ListItemBag) => item.value ?? "") ?? [];
        },
        set(newValue: string[]) {
            selectedLocations.value = newValue.map((value: string) => ({
                value
            }));
        }
    });

    const selectedScheduleIds = computed<string[]>({
        get() {
            return selectedSchedules.value
                ?.filter((item: ListItemBag) => item?.value)
                ?.map((item: ListItemBag) => item.value ?? "") ?? [];
        },
        set(newValue: string[]) {
            selectedSchedules.value = newValue.map((value: string) => ({
                value
            }));
        }
    });

    // #endregion

    // #region Functions

    /**
     * Gets the sliding date range from the provided sliding date range bag.
     *
     * @param bag The date range bag from which to create a sliding date range.
     */
    function getSlidingDateRange(bag: SlidingDateRangeBag | null | undefined): SlidingDateRange | null {
        return bag
            ? bag as SlidingDateRange
            : null;
    }

    /**
     * Gets the current filters according the the controls' selected values.
     */
    function getCurrentFilters(): GroupSchedulerFiltersBag {
        var dateRange: SlidingDateRangeBag | null = selectedDateRange.value
            ? selectedDateRange.value as SlidingDateRangeBag
            : null;

        return {
            groups: selectedGroups.value,
            locations: {
                selectedLocations: selectedLocations.value
            },
            schedules: {
                selectedSchedules: selectedSchedules.value
            },
            dateRange
        };
    }

    /**
     * Sets the internal values using the provided filters.
     *
     * @param filters The filters value from which to set the internal values.
     */
    function setCurrentFilters(filters: GroupSchedulerFiltersBag | null): void {
        selectedGroups.value = filters?.groups ?? [];
        selectedDateRange.value = getSlidingDateRange(filters?.dateRange);
        availableLocations.value = filters?.locations?.availableLocations ?? [];
        selectedLocations.value = filters?.locations?.selectedLocations ?? [];
        availableSchedules.value = filters?.schedules?.availableSchedules ?? [];
        selectedSchedules.value = filters?.schedules?.selectedSchedules ?? [];
    }

    // #endregion

    // #region Event Handlers

    /**
     * Handles the `save` event of the select filters modal.
     */
    function onSave(): void {
        emit("applyFilters", getCurrentFilters());
        isCanceled.value = false;
        isVisible.value = false;
    }

    /**
     * Handles the updating of filter values within this component, based on the current combined values of all filter controls.
     */
    async function onFiltersChanged(target: string, event: any): Promise<void> {
        /*
         * When one of the filter controls triggers this event handler, we could find ourselves in an infinite loop without
         * this initial `isUpdatingFilters.value` check (because all such controls will be updated with the server's response
         * to the initial change event, thereby repeatedly triggering this event handler over and over). Note the `nextTick`
         * usage below, which will set `isUpdatingFilters.value` back to false once the controls have all had a chance to
         * update their values accordingly.
         */
        if (isUpdatingFilters.value) {
            console.log(`${target}: Ignoring follow-up event.`);
            return;
        }

        isUpdatingFilters.value = true;
        warningMessage.value = "";

        const result = await invokeBlockAction<GroupSchedulerFiltersBag>("UpdateFilters", { bag: getCurrentFilters() });
        if (!result.isSuccess) {
            isUpdatingFilters.value = false;
            warningMessage.value = result.errorMessage || "Unknown error while trying to update available filters.";
            return;
        }

        setCurrentFilters(result.data);

        nextTick(() => {
            isUpdatingFilters.value = false;
        });
    }

    // #endregion

    // Watch for applied filters props changes and update our original and internal values.
    watch(() => props.appliedFilters, () => {
        originalValue.value = props.appliedFilters;
        setCurrentFilters(props.appliedFilters);
    });

    // Watch for the modal closing without the save button being clicked and revert any changes to internal values.
    watch(isVisible, () => {
        if (isVisible.value) {
            isCanceled.value = true;
        }
        else {
            if (isCanceled.value) {
                setCurrentFilters(originalValue.value);
            }
        }
    });
</script>
